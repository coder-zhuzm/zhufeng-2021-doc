"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const build_utils_1 = require("@vercel/build-utils");
const nft_1 = require("@vercel/nft");
const build = async ({ entrypoint, files, workPath, config, meta = {}, }) => {
    const { installCommand, buildCommand } = config;
    await (0, build_utils_1.download)(files, workPath, meta);
    const mountpoint = (0, path_1.dirname)(entrypoint);
    const entrypointFsDirname = (0, path_1.join)(workPath, mountpoint);
    // Run "Install Command"
    const nodeVersion = await (0, build_utils_1.getNodeVersion)(entrypointFsDirname, undefined, config, meta);
    const spawnOpts = (0, build_utils_1.getSpawnOptions)(meta, nodeVersion);
    if (!spawnOpts.env) {
        spawnOpts.env = {};
    }
    const { cliType, lockfileVersion } = await (0, build_utils_1.scanParentDirs)(entrypointFsDirname);
    if (cliType === 'npm') {
        if (typeof lockfileVersion === 'number' &&
            lockfileVersion >= 2 &&
            ((nodeVersion === null || nodeVersion === void 0 ? void 0 : nodeVersion.major) || 0) < 16) {
            // Ensure that npm 7 is at the beginning of the `$PATH`
            spawnOpts.env.PATH = `/node16/bin-npm7${path_1.delimiter}${spawnOpts.env.PATH}`;
            console.log('Detected `package-lock.json` generated by npm 7...');
        }
    }
    else if (cliType === 'pnpm') {
        if (typeof lockfileVersion === 'number' && lockfileVersion === 5.4) {
            // Ensure that pnpm 7 is at the beginning of the `$PATH`
            spawnOpts.env.PATH = `/pnpm7/node_modules/.bin${path_1.delimiter}${spawnOpts.env.PATH}`;
            console.log('Detected `pnpm-lock.yaml` generated by pnpm 7...');
        }
    }
    if (typeof installCommand === 'string') {
        if (installCommand.trim()) {
            console.log(`Running "install" command: \`${installCommand}\`...`);
            const env = {
                YARN_NODE_LINKER: 'node-modules',
                ...spawnOpts.env,
            };
            await (0, build_utils_1.execCommand)(installCommand, {
                ...spawnOpts,
                env,
                cwd: entrypointFsDirname,
            });
        }
        else {
            console.log(`Skipping "install" command...`);
        }
    }
    else {
        await (0, build_utils_1.runNpmInstall)(entrypointFsDirname, [], spawnOpts, meta, nodeVersion);
    }
    // Make `remix build` output production mode
    spawnOpts.env.NODE_ENV = 'production';
    // Run "Build Command"
    if (buildCommand) {
        (0, build_utils_1.debug)(`Executing build command "${buildCommand}"`);
        await (0, build_utils_1.execCommand)(buildCommand, {
            ...spawnOpts,
            cwd: entrypointFsDirname,
        });
    }
    else {
        const pkg = await (0, build_utils_1.readConfigFile)((0, path_1.join)(entrypointFsDirname, 'package.json'));
        if (hasScript('vercel-build', pkg)) {
            (0, build_utils_1.debug)(`Executing "yarn vercel-build"`);
            await (0, build_utils_1.runPackageJsonScript)(entrypointFsDirname, 'vercel-build', spawnOpts);
        }
        else if (hasScript('build', pkg)) {
            (0, build_utils_1.debug)(`Executing "yarn build"`);
            await (0, build_utils_1.runPackageJsonScript)(entrypointFsDirname, 'build', spawnOpts);
        }
        else {
            await (0, build_utils_1.execCommand)('remix build', {
                ...spawnOpts,
                cwd: entrypointFsDirname,
            });
        }
    }
    let serverBuildPath = 'build/index.js';
    let needsHandler = true;
    try {
        const remixConfig = require((0, path_1.join)(entrypointFsDirname, 'remix.config'));
        // If `serverBuildTarget === 'vercel'` then Remix will output a handler
        // that is already in Vercel (req, res) format, so don't inject the handler
        if (remixConfig.serverBuildTarget) {
            if (remixConfig.serverBuildTarget !== 'vercel') {
                throw new Error(`\`serverBuildTarget\` in Remix config must be "vercel" (got "${remixConfig.serverBuildTarget}")`);
            }
            serverBuildPath = 'api/index.js';
            needsHandler = false;
        }
        if (remixConfig.serverBuildPath) {
            // Explicit file path where the server output file will be
            serverBuildPath = remixConfig.serverBuildPath;
        }
        else if (remixConfig.serverBuildDirectory) {
            // Explicit directory path the server output will be
            serverBuildPath = (0, path_1.join)(remixConfig.serverBuildDirectory, 'index.js');
        }
    }
    catch (err) {
        // Ignore error if `remix.config.js` does not exist
        if (err.code !== 'MODULE_NOT_FOUND')
            throw err;
    }
    const [staticFiles, renderFunction] = await Promise.all([
        (0, build_utils_1.glob)('**', (0, path_1.join)(entrypointFsDirname, 'public')),
        createRenderFunction(entrypointFsDirname, serverBuildPath, needsHandler, nodeVersion),
    ]);
    return {
        routes: [
            {
                src: '^/build/(.*)$',
                headers: { 'cache-control': 'public, max-age=31536000, immutable' },
                continue: true,
            },
            {
                handle: 'filesystem',
            },
            {
                src: '/(.*)',
                dest: '/render',
            },
        ],
        output: {
            render: renderFunction,
            ...staticFiles,
        },
    };
};
exports.build = build;
function hasScript(scriptName, pkg) {
    const scripts = (pkg && pkg.scripts) || {};
    return typeof scripts[scriptName] === 'string';
}
async function createRenderFunction(rootDir, serverBuildPath, needsHandler, nodeVersion) {
    const files = {};
    const handler = needsHandler
        ? (0, path_1.join)((0, path_1.dirname)(serverBuildPath), '__vc_handler.js')
        : serverBuildPath;
    const handlerPath = (0, path_1.join)(rootDir, handler);
    if (needsHandler) {
        // Copy the `default-server.js` file into the "build" directory
        const sourceHandlerPath = (0, path_1.join)(__dirname, '../default-server.js');
        await fs_1.promises.copyFile(sourceHandlerPath, handlerPath);
    }
    // Trace the handler with `@vercel/nft`
    const trace = await (0, nft_1.nodeFileTrace)([handlerPath], {
        base: rootDir,
    });
    let needsVercelAdapter = false;
    for (const warning of trace.warnings) {
        if (warning.message.includes("'@remix-run/vercel'")) {
            needsVercelAdapter = true;
        }
        else if (warning.stack) {
            (0, build_utils_1.debug)(warning.stack.replace('Error: ', 'Warning: '));
        }
    }
    for (const file of trace.fileList) {
        files[file] = await build_utils_1.FileFsRef.fromFsPath({ fsPath: (0, path_1.join)(rootDir, file) });
    }
    if (needsVercelAdapter) {
        // Package in the Builder's version of `@remix-run/vercel` Runtime adapter
        const remixVercelPackageJsonPath = require.resolve('@remix-run/vercel/package.json', {
            paths: [__dirname],
        });
        const remixVercelPackageJson = require(remixVercelPackageJsonPath);
        const remixVercelDir = (0, path_1.dirname)(remixVercelPackageJsonPath);
        const remixVercelEntrypoint = (0, path_1.join)(remixVercelDir, 'index.js');
        console.log(`Warning: Implicitly adding \`${remixVercelPackageJson.name}\` v${remixVercelPackageJson.version} to your project. You should add this dependency to your \`package.json\` file.`);
        const adapterBase = (0, path_1.join)(remixVercelDir, '../../..');
        const adapterTrace = await (0, nft_1.nodeFileTrace)([remixVercelEntrypoint], {
            base: adapterBase,
        });
        for (const file of adapterTrace.fileList) {
            files[file] = await build_utils_1.FileFsRef.fromFsPath({
                fsPath: (0, path_1.join)(adapterBase, file),
            });
        }
    }
    const lambda = new build_utils_1.NodejsLambda({
        files,
        handler,
        runtime: nodeVersion.runtime,
        shouldAddHelpers: false,
        shouldAddSourcemapSupport: false,
    });
    return lambda;
}
//# sourceMappingURL=build.js.map